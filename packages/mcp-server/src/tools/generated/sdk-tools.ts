/**
 * Auto-generated SDK Tools
 *
 * This file is generated by the MCP tool generator.
 * DO NOT EDIT MANUALLY - changes will be overwritten.
 *
 * Generated at: 2025-12-16T21:15:32.240Z
 * Tool count: 47
 *
 * To regenerate: npm run generate
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import type { UiPathClient } from '../../server/index.js';

/**
 * Register all SDK-based MCP tools
 */
export function registerSDKTools(server: McpServer, client: UiPathClient): void {

  // ============================================
  // Action Center
  // ============================================

  server.tool(
    'action_center_task_create',
    "Creates a new task",
    {
  task: z.object({}).passthrough().describe("to be created\n   *"),
  folderId: z.number().describe("Required folder ID\n   *")
},
    async (params) => {
      try {
        const { folderId, ...data } = params as any;
        const result = await client.tasks.create(data, folderId);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'action_center_task_getUsers',
    "Gets users in the given folder who have Tasks.View and Tasks.Edit permissions\n\nThe method returns either:\n- An array of users (when no pagination parameters are provided)\n- A paginated result with navigation cursors (when any pagination parameter is provided)",
    {
  folderId: z.number().describe("The folder ID to get users from\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("Optional query and pagination parameters\n   *")
},
    async (params) => {
      try {
        const { folderId, ...options } = params as any;
        const result = await client.tasks.getUsers(folderId, options);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'action_center_task_getAll',
    "Gets tasks across folders with optional filtering and folder scoping\n\nThe method returns either:\n- An array of tasks (when no pagination parameters are provided)\n- A paginated result with navigation cursors (when any pagination parameter is provided)",
    {
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("*")
},
    async (params) => {
      try {
        const result = await client.tasks.getAll(params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'action_center_task_getById',
    "Gets a task by ID\nIMPORTANT: For form tasks, folderId must be provided.",
    {
  id: z.number().describe("The ID of the task to retrieve\n   *"),
  options: z.object({}).passthrough().optional().describe("Optional query parameters\n   *"),
  folderId: z.union([z.number(), z.null()]).optional().describe("Optional folder ID (REQUIRED for form tasks)\n   *")
},
    async (params) => {
      try {
        const result = await client.tasks.getById((params as any).id, {}, (params as any).folderId);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'action_center_task_assign',
    "Assigns tasks to users",
    {
  taskAssignments: z.array(z.union([z.object({}).passthrough(), z.object({}).passthrough()])).describe("Single task assignment or array of task assignments\n   *")
},
    async (params) => {
      try {
        const result = await client.tasks.assign(params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'action_center_task_reassign',
    "Reassigns tasks to new users",
    {
  taskAssignments: z.array(z.union([z.object({}).passthrough(), z.object({}).passthrough()])).describe("Single task assignment or array of task assignments\n   *")
},
    async (params) => {
      try {
        const result = await client.tasks.reassign(params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'action_center_task_unassign',
    "Unassigns tasks (removes current assignees)",
    {
  taskIds: z.array(z.union([z.number(), z.number()])).describe("Single task ID or array of task IDs to unassign\n   *")
},
    async (params) => {
      try {
        const result = await client.tasks.unassign((params as any).taskIds);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'action_center_task_complete',
    "Completes a task with the specified type and data",
    {
  options: z.object({}).passthrough().describe("including task type, taskId, data, and action\n   *"),
  folderId: z.number().describe("Required folder ID\n   *")
},
    async (params) => {
      try {
        const { folderId, ...options } = params as any;
        const result = await client.tasks.complete(options, folderId);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  // ============================================
  // Data Fabric
  // ============================================

  server.tool(
    'data_fabric_entity_getById',
    "Gets entity metadata by entity ID with attached operation methods",
    {
  id: z.string().describe("UUID of the entity\n   *")
},
    async (params) => {
      try {
        const result = await client.entities.getById((params as any).id);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'data_fabric_entity_getRecordsById',
    "Gets entity records by entity ID",
    {
  entityId: z.string().describe("UUID of the entity\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("*")
},
    async (params) => {
      try {
        const result = await client.entities.getRecordsById((params as any).entityId, (params as any).options);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'data_fabric_entity_insertById',
    "Inserts data into an entity by entity ID",
    {
  id: z.string(),
  data: z.array(z.record(z.string(), z.any())).describe("Array of records to insert\n   *"),
  options: z.object({}).passthrough().optional().describe("*")
},
    async (params) => {
      try {
        const result = await client.entities.insertById((params as any).id, (params as any).data);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'data_fabric_entity_updateById',
    "Updates data in an entity by entity ID",
    {
  id: z.string(),
  data: z.array(z.object({}).passthrough()).describe("Array of records to update. Each record MUST contain the record Id,\n   *               otherwise the update will fail.\n   *"),
  options: z.object({}).passthrough().optional().describe("*")
},
    async (params) => {
      try {
        const result = await client.entities.updateById((params as any).id, (params as any).data);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'data_fabric_entity_deleteById',
    "Deletes data from an entity by entity ID",
    {
  id: z.string(),
  recordIds: z.array(z.string()).describe("Array of record UUIDs to delete\n   *"),
  options: z.object({}).passthrough().optional().describe("*")
},
    async (params) => {
      try {
        const result = await client.entities.deleteById((params as any).id, (params as any).recordIds);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'data_fabric_entity_getAll',
    "Gets all entities in the system",
    {
  
},
    async (params) => {
      try {
        const result = await client.entities.getAll();
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  // ============================================
  // Maestro
  // ============================================

  server.tool(
    'maestro_case_instances_getAll',
    "Get all case instances with optional filtering and pagination\n\nThe method returns either:\n- A NonPaginatedResponse with items array (when no pagination parameters are provided)\n- A PaginatedResponse with navigation cursors (when any pagination parameter is provided)",
    {
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("Query parameters for filtering instances and pagination\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.cases.instances.getAll(params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_case_instances_getById',
    "Get a case instance by ID with operation methods (close, pause, resume)",
    {
  instanceId: z.string().describe("The ID of the instance to retrieve\n   *"),
  folderKey: z.string().describe("Required folder key\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.cases.instances.getById((params as any).instanceId, (params as any).folderKey);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_case_instances_close',
    "Close a case instance",
    {
  instanceId: z.string().describe("The ID of the instance to cancel\n   *"),
  folderKey: z.string().describe("Required folder key\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("with comment\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.cases.instances.close((params as any).instanceId, (params as any).folderKey, (params as any).options);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_case_instances_pause',
    "Pause a case instance",
    {
  instanceId: z.string().describe("The ID of the instance to pause\n   *"),
  folderKey: z.string().describe("Required folder key\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("with comment\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.cases.instances.pause((params as any).instanceId, (params as any).folderKey, (params as any).options);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_case_instances_resume',
    "Resume a case instance",
    {
  instanceId: z.string().describe("The ID of the instance to resume\n   *"),
  folderKey: z.string().describe("Required folder key\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("with comment\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.cases.instances.resume((params as any).instanceId, (params as any).folderKey, (params as any).options);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_case_instances_getExecutionHistory',
    "Get execution history for a case instance",
    {
  instanceId: z.string().describe("The ID of the case instance\n   *"),
  folderKey: z.string().describe("Required folder key\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.cases.instances.getExecutionHistory((params as any).instanceId || (params as any).caseInstanceId, (params as any).folderKey);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_case_instances_getStages',
    "Get case stages with their associated tasks and execution status",
    {
  caseInstanceId: z.string().describe("The ID of the case instance\n   *"),
  folderKey: z.string().describe("Required folder key\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.cases.instances.getStages((params as any).instanceId || (params as any).caseInstanceId, (params as any).folderKey);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_case_instances_getActionTasks',
    "Get human in the loop tasks associated with a case instance",
    {
  caseInstanceId: z.string().describe("The ID of the case instance\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("*")
},
    async (params) => {
      try {
        const result = await client.maestro.cases.instances.getActionTasks((params as any).caseInstanceId, (params as any).options);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_cases_getAll',
    "Get all case management processes with their instance statistics",
    {
  
},
    async (params) => {
      try {
        const result = await client.maestro.cases.getAll();
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_process_incidents_getAll',
    "Get all process incidents across all folders",
    {
  
},
    async (params) => {
      try {
        const result = await client.maestro.processes.incidents.getAll();
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_process_instances_getAll',
    "Get all process instances with optional filtering and pagination\n\nThe method returns either:\n- A NonPaginatedResponse with items array (when no pagination parameters are provided)\n- A PaginatedResponse with navigation cursors (when any pagination parameter is provided)",
    {
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("Query parameters for filtering instances and pagination\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.processes.instances.getAll(params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_process_instances_getById',
    "Get a process instance by ID with operation methods (cancel, pause, resume)",
    {
  id: z.string().describe("The ID of the instance to retrieve\n   *"),
  folderKey: z.string().describe("The folder key for authorization\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.processes.instances.getById((params as any).id, (params as any).folderKey);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_process_instances_getExecutionHistory',
    "Get execution history (spans) for a process instance",
    {
  instanceId: z.string().describe("The ID of the instance to get history for\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.processes.instances.getExecutionHistory((params as any).instanceId);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_process_instances_getBpmn',
    "Get BPMN XML file for a process instance",
    {
  instanceId: z.string().describe("The ID of the instance to get BPMN for\n   *"),
  folderKey: z.string().describe("The folder key for authorization\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.processes.instances.getBpmn((params as any).instanceId, (params as any).folderKey);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_process_instances_cancel',
    "Cancel a process instance",
    {
  instanceId: z.string().describe("The ID of the instance to cancel\n   *"),
  folderKey: z.string().describe("The folder key for authorization\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("with comment\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.processes.instances.cancel((params as any).instanceId, (params as any).folderKey, (params as any).options);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_process_instances_pause',
    "Pause a process instance",
    {
  instanceId: z.string().describe("The ID of the instance to pause\n   *"),
  folderKey: z.string().describe("The folder key for authorization\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("with comment\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.processes.instances.pause((params as any).instanceId, (params as any).folderKey, (params as any).options);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_process_instances_resume',
    "Resume a process instance",
    {
  instanceId: z.string().describe("The ID of the instance to resume\n   *"),
  folderKey: z.string().describe("The folder key for authorization\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("with comment\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.processes.instances.resume((params as any).instanceId, (params as any).folderKey, (params as any).options);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_process_instances_getVariables',
    "Get global variables for a process instance",
    {
  instanceId: z.string().describe("The ID of the instance to get variables for\n   *"),
  folderKey: z.string().describe("The folder key for authorization\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("including parentElementId to filter by parent element\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.processes.instances.getVariables((params as any).instanceId, (params as any).folderKey);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_process_instances_getIncidents',
    "Get incidents for a process instance",
    {
  instanceId: z.string().describe("The ID of the instance to get incidents for\n   *"),
  folderKey: z.string().describe("The folder key for authorization\n   *")
},
    async (params) => {
      try {
        const result = await client.maestro.processes.instances.getIncidents((params as any).instanceId, (params as any).folderKey);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_maestro_processes_getAll',
    "Get all processes with their instance statistics",
    {
  
},
    async (params) => {
      try {
        const result = await client.maestro.processes.getAll();
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'maestro_maestro_processes_getIncidents',
    "Get incidents for a specific process",
    {
  processKey: z.string(),
  folderKey: z.string()
},
    async (params) => {
      try {
        const result = await client.maestro.processes.getIncidents((params as any).processKey, (params as any).folderKey);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  // ============================================
  // Orchestrator
  // ============================================

  server.tool(
    'orchestrator_asset_getAll',
    "Gets all assets across folders with optional filtering and folder scoping",
    {
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("*")
},
    async (params) => {
      try {
        const result = await client.assets.getAll(params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_asset_getById',
    "Gets a single asset by ID",
    {
  id: z.number().describe("Asset ID\n   *"),
  folderId: z.number().describe("Required folder ID\n   *"),
  options: z.object({}).passthrough().optional().describe("Optional query parameters (expand, select)\n   *")
},
    async (params) => {
      try {
        const result = await client.assets.getById((params as any).id, (params as any).folderId);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_bucket_getById',
    "Gets a bucket by ID",
    {
  id: z.number(),
  folderId: z.number().describe("Folder ID for organization unit context\n   *"),
  options: z.object({}).passthrough().optional().describe("Optional query parameters (expand, select)\n   *")
},
    async (params) => {
      try {
        const result = await client.buckets.getById((params as any).id, (params as any).folderId);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_bucket_getAll',
    "Gets all buckets across folders with optional filtering and folder scoping\n\nThe method returns either:\n- An array of buckets (when no pagination parameters are provided)\n- A paginated result with navigation cursors (when any pagination parameter is provided)",
    {
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("including optional folderId\n   *")
},
    async (params) => {
      try {
        const result = await client.buckets.getAll(params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_bucket_getFileMetaData',
    "Gets metadata for files in a bucket with optional filtering and pagination\n\nThe method returns either:\n- A NonPaginatedResponse with items array (when no pagination parameters are provided)\n- A PaginatedResponse with navigation cursors (when any pagination parameter is provided)",
    {
  bucketId: z.number().describe("The ID of the bucket to get file metadata from\n   *"),
  folderId: z.number().describe("Required folder ID for organization unit context\n   *"),
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("Optional parameters for filtering, pagination and access URL generation\n   *")
},
    async (params) => {
      try {
        const result = await client.buckets.getFileMetaData((params as any).bucketId, (params as any).folderId, (params as any).options);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_bucket_uploadFile',
    "Uploads a file to a bucket",
    {
  options: z.object({}).passthrough().describe("Options for file upload including bucket ID, folder ID, path, content, and optional parameters\n   *")
},
    async (params) => {
      try {
        const result = await client.buckets.uploadFile((params as any).options || params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_bucket_getReadUri',
    "Gets a direct download URL for a file in the bucket",
    {
  options: z.object({}).passthrough().describe("Contains bucketId, folderId, file path and optional expiry time\n   *")
},
    async (params) => {
      try {
        const result = await client.buckets.getReadUri((params as any).options || params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_process_getAll',
    "Gets all processes across folders with optional filtering and folder scoping\n\nThe method returns either:\n- An array of processes (when no pagination parameters are provided)\n- A paginated result with navigation cursors (when any pagination parameter is provided)",
    {
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("including optional folderId\n   *")
},
    async (params) => {
      try {
        const result = await client.processes.getAll(params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_process_start',
    "Starts a process execution (job)",
    {
  request: z.object({}).passthrough().describe("body\n   *"),
  folderId: z.number().describe("Required folder ID\n   *"),
  options: z.object({}).passthrough().optional().describe("Optional query parameters\n   *")
},
    async (params) => {
      try {
        const { folderId, ...request } = params as any;
        const result = await client.processes.start(request, folderId);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_process_getById',
    "Gets a single process by ID",
    {
  id: z.number().describe("Process ID\n   *"),
  folderId: z.number().describe("Required folder ID\n   *"),
  options: z.object({}).passthrough().optional().describe("Optional query parameters \n   *")
},
    async (params) => {
      try {
        const result = await client.processes.getById((params as any).id, (params as any).folderId);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_queue_getAll',
    "Gets all queues across folders with optional filtering and folder scoping\n\nThe method returns either:\n- An array of queues (when no pagination parameters are provided)\n- A paginated result with navigation cursors (when any pagination parameter is provided)",
    {
  options: z.union([z.object({}).passthrough(), z.null()]).optional().describe("including optional folderId\n   *")
},
    async (params) => {
      try {
        const result = await client.queues.getAll(params as any);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );

  server.tool(
    'orchestrator_queue_getById',
    "Gets a single queue by ID",
    {
  id: z.number().describe("Queue ID\n   *"),
  folderId: z.number().describe("Required folder ID\n   *"),
  options: z.object({}).passthrough().optional()
},
    async (params) => {
      try {
        const result = await client.queues.getById((params as any).id, (params as any).folderId);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return {
          content: [{ type: 'text', text: `Error: ${message}` }],
          isError: true
        };
      }
    }
  );
}
